# 二叉树总结篇

核心问题——**遍历**：

1. 递归遍历
2. 迭代遍历

两种遍历方式都有其适配的场景，有些题目得用特定的遍历方式才好解决。

难点——**递归遍历条件的设置，递归方程的设计**：

具体可以参考236、450、501这几题，这几题是递归遍历的难点

对于**236.二叉树的最近公共祖先**，这题的难点在于怎么去设计递归的返回结果，寻找公共祖先，对于每一个节点，都需要进行判断，除了尝试对当前节点进行判断：空值判断以及是不是p或者q节点。还需要进行左右子树的递归，其中左右子树的递归判断一共是三种结果：

1. 左子树找到了
2. 右子树找到了
3. 都没找到或者都找到了

![image-20241115231329911](./images/image-20241115231329911.png)

判断完之后返回当前最有可能成为目标节点的node。

类似的题目是：**235.二叉搜素树的公共祖先**，可以利用二叉搜索树的性质进行剪枝优化，进而提高递归效率

对于**450.删除二叉搜索树中的节点**也是进行递归判断：如果找不到target，就根据搜索树的性质继续深搜，否则就删除节点，寻找替换值（右子树的最小值），并递归的删除这个最小值（如果期间还发生了节点的变换，那根据递归的性质可以自行解决了）

对于**501.二叉搜索树中的众数**则需要灵活地利用中序遍历（遍历到的数值有序且连接成片）的方式，通过`count`，`base`，`maxCount`等参数进行众数覆盖与计算。

